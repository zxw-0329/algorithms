/*
  题目大意: 对于n个位置，不能连续的m个位置放相同的东西的 方案数
  
  启发 1：对于任意一个位置都有 放/不放 这个东西的两种状态；
  
  对m 可以开m维数组来定义状态 
  例如  m=2 定义dp[i][j]:代表长度为i且以j结尾的且不含2个连续相同的数量（j可以是0/1）------->参考题目（不要11）
        状态转移:dp[i][0] =  dp[i - 1][0] + dp[i - 1][1];  //以 0 结尾
                 dp[i][1] = dp[i - 1][0] ;  //以 1 结尾
                 
        m=3 定义dp[i][j][k]:代表长度为i且以j k结尾的且不含3个连续相同的数量 (j,k可以是0/1其中任意一个)------->参考题目（核电站问题）
        状态转移:dp[i][0][0] = dp[i - 1][0][0] + dp[i - 1][1][0];
                dp[i][0][1] = dp[i - 1][0][0] + dp[i - 1][1][0];
                dp[i][1][0] = dp[i - 1][0][1] + dp[i - 1][1][1];
                dp[i][1][1] = dp[i - 1][0][1];
                
   思考：如果对于更大的m怎么办 还能开m维数组吗  答案显然是不能的
         如果只用一个一维数组能否实现你 ？
         定义dp[i]：表示到第i个位置合法的方案数;
         dp[0] = 1;
         由启发1 可知
         对于 第i位置 有3种情况讨论
         1. i < m
           对于每个位置都可以选择 放和不放
           可以得到递推公式 dp[i]=2*dp[i-1]
         2. i==m
            此时已经恰好够m个位置,要减去全为相同东西的情况
            dp[i]=2*dp[i]-1
         3. i > m
            dp[i]=2*dp[i-1]-dp[i-m-1] (要减去以放东西结尾的不合法方案数)
            
            从i-1开始，一直到i-m+1这个位置结束，一共有m-1个坑（1到3有3个数，而不是3-1=2个数）放入了东西。
            这个时候，如果在i位置放入东西，则肯定会爆炸。
            因此，i-m这个位置，一定不能放入东西！否则在你决定是否在i位置上放东西之前就已经爆炸了。
            所以，从i-1这个位置开始，一直到i-m这个位置结束，这一系列的位置上，放不放入东西都是已经确定了的，所以这里只算一种情况。（全放东西）
            再来看i-m-1这个位置，那么这个位置放不放就不确定了，因此有dp(i-m-1)种放法。
            这么多种放法，只要乘上前面这一种放法（从i-m到i-1的这一种放法），就是dp(i-m-1)，

        https://acm.webturing.com/problem.php?id=1127
*/
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
int dp[50][2][2];
int m = 3;
int main() {
   ios::sync_with_stdio(false);
   cin.tie(nullptr);
   cout.tie(nullptr);
   int n;
   cin >> n;
   
   // dp[2][0][1] = 1;
   // dp[2][0][0] = 1;
   // dp[2][1][0] = 1;
   // dp[2][1][1] = 1;
   // for (int i = 3; i <= n; i++) {
   //    dp[i][0][0] = dp[i - 1][0][0] + dp[i - 1][1][0];
   //    dp[i][0][1] = dp[i - 1][0][0] + dp[i - 1][1][0];
   //    dp[i][1][0] = dp[i - 1][0][1] + dp[i - 1][1][1];
   //    dp[i][1][1] = dp[i - 1][0][1];
   // }
   // cout << dp[n][0][0] + dp[n][0][1] + dp[n][1][0] + dp[n][1][1] << "\n";
   vector<ll>dp(n + 1);
   dp[2] = 4;
   dp[1] = 2;
   dp[0] = 1;
   dp[3] = 7;
   for (int i = 4; i <= n; i++) {
      dp[i] = dp[i - 1] * 2 - dp[i - m - 1];
   }
   cout << dp[n];
   return 0;
}
